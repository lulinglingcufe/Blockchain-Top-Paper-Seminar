今天和大家分享一篇ICED2019的论文。主要介绍了一种应用于以太坊区块链的数据结构。他们取名为GME树。能够使用它来对区块链上的数据进行可信的范围查询。并且这种数据结构的特点是能节省gas。

区块链的核心数据结构是，由不信任的节点共同维护的分布式账本。

对于区块链系统的一个重要组件智能合约，作者给了一个定义。
它是一种可信程序，在区块链上执行用户自定义的计算。
它可以读写区块链的数据。它执行的完整性，由共识协议来保证。
它为区块链提供了可信存储与计算的能力。
因此他们做了一个比较，对于计算机来说，存储是RAM，计算单元是CPU。对于区块链来说存储单元是，分布式账本。计算单元是 智能合约。

作者认为区块链是存在可扩展性问题的。具体表现为，在区块链上存储的数据量是要受到限制的。对于以太坊来说，每15秒产生一个区块，一个区块20字节。很显然，对于文件、图像等大数据，只能存储在链下的数据库里。
这些数据被称为原始数据。它们的hash值会被写在链上，来作为不可篡改的证明。

因此，作者首先描述了一种区块链混合存储模型。
数据拥有者如果想把数据写到区块链上。把数据hash之后，放到区块链上。完整的数据，会放在一个链下数据库，服务提供者处。通过一个key，可以检索到数据。
对于client来说，他从服务提供者处查找key对应的数据。从区块链上查找hash值。如果数据的hash是匹配的，可以确定链下数据的完整性。
优点在于，可扩展性提高，同时保证安全性。缺点在于只能支持精确查询。作者就思考能不能支持更多类型的查询呢？他们给出了一种支持范围查询的方案。它的核心是一种可信数据结构。
在数据拥有者，把数据写到区块链上后。区块链的智能合约，以及服务提供者都会维护一种可信数据结构ADS。当client向服务提供者发起一个范围查询后，服务提供者会返回一个 result查询结果，附加 verifiable object，即查询结果的完整性证明。结合client从区块链上获得的验证对象，client就可以确认，服务提供者返回的查询结果是正确的。

这样的设计会遇到什么样的挑战呢？对区块链数据进行写操作，是通过一笔交易进行的。对于以太坊来说，他引入了gas，一笔交易中，智能合约进行不同的计算操作，花费的gas数量不同。这样就防止DDOS攻击。类似于CPU做某些操作，花费的CPU时间会多一些。对于以太坊，sload操作，把一个word从存储里取出来。花费200gas。sstore，存入一个word花费2万gas。访问内存中的一个word花费3gas。做hash操作的gas。作者设计的ads数据结构，是要节省gas的。他们的贡献就是提出这样一种数据结构，并进行了优化。

我们来讲一下基础的原理。ADS VO是外包计算中的名词。外包计算是06年 SIGMOD 上一篇论文提出的概念。ADS这种数据结构可以用Merkelhash树来实现。
作者结合MHT和B树。首先数据从4到38，是排好序的。比如查询10到20这个范围里的数据。结果是13和16。验证对象是 4 24 及h6。把h7算出来。两者相符，说明查询结果是完整的。

因此在前面的系统架构中。用户向服务提供者发出10到20的一个范围查询。他从智能合约获取了 验证对象 h7 根hash。从服务提供者那里获取的是 验证对象 4，24 h6以及结果 13 16 。

作为ADS的一种基本解决方案。MBtree这种数据结构，智能合约和服务提供者都需要维护。如果发生数据跟新，路径上所有的节点都需要更新。
作者分析了，一次数据插入需要花费的gas，计算公式是这样的。以F为底，求N对数。N代表了数据库中的数据量。F是一个节点，子节点的数量（fanout扇出）。

注意到，对于智能合约来说只需要提供一个根节点。因此提出了一种被压缩的 Merkle树。

所有的中间节点都不存在区块链上，只存root节点。之前提过，智能合约从内存里获取数据花费很少的gas。因此计算SMB树root节点的过程就直接交给内存。区块链只存root节点和叶子节点（数据）就行了。

但是服务提供者，是需要维护完整的SMBtree数据结构的。他的计算资源和存储资源都是很丰富的。

SMB树插入一个数据消耗的gas。是这样一个公式。N是数据库中的数据量。

随着数据库中数据数量增加，插入数据消耗gas如图所示。显然，在数据量较小时，使用SMBtree来索引节点，插入消耗小。数据量较大时，使用MBtree更加优化。

因此，他们提出了Merkel合并树的结构。使用一系列较小的SMBtree来索引新插入的数据。维护一个完整的MB树，批量合并大规模SMBtree的对象。

左边是智能合约维护的ADS数据结构，右边是服务提供者维护的ADS数据结构

首先看key-storage的数据结构：第一个位置对应的key是68，第二个位置对应的key是32。位置排序是按照key插入顺序来的。valuestorage保存的是一个key对应的hash value.

P表示partition，分组。每个分组中有一颗或者两颗树。每棵树的大小是2的指数次。如P3中每棵树的大小是2。P2中，每棵树的大小是4。P1中每棵树的大小是8。另外还维护了一个辅助的分组索引表。parttable。因为一个分组中有两棵树。左数和右数。存储树的hashroot,树里面数据的位置范围。

注意到，在智能合约的ADS数据结构中，对key是不作排序的。但是在服务提供者处，对key作了排序。并且服务提供者维护了，树所有的中间节点。

智能合约只存储-树root和叶子节点。
智能合约获得树root，是通过EVM进行计算的。这个计算过程不涉及链上数据存储。

在智能合约中，keymap存储了key的位置信息。用于更新数据。

我们来看一下数据的插入过程。一开始只有一个分组，包含左右两棵树，四个空位。如果有超过4个数据要存储。P1左右两棵树会合并成1颗。新建一个P2的分组。新数据首先插入到P2中。数据量继续增加，P2的两棵树合并后，成为P1中的右树。
数据继续增加的话，就新建分组和树，把原先的树进行合并。

对于更新，树的结构不变，roothash重新算。

对于查询，服务提供者需要遍历多个树结构，每个都执行范围查询。把每棵树的结果和证明都返回给client。

client结合区块链上的treeroot，和服务提供者返回的数据，检查结果的完整性。

接着作者提出了一种优化的两层索引结构。主要针对key的数据分布。比如正态分布、均匀分布等进行优化。

在第一层，把key的搜索域进行分段。最好的情况下，每个分段里的key数量是相同的。
第二层，每个分段都有一个GEM树。

最后是实验结果。数据是由Yahoo Cloud System Benchmark产生的。
测试了两种分布：均匀分布、齐夫分布。

实验结果表明，优化后的树结构，在插入数据量增长时消耗的gas最少。

在更新数据时，优化树表现也比较好，更新花费的gas比插入小。

查询验证操作的性能：选择范围增加的时候，服务提供者需要计算的CPU时间。client验证结果的CPU时间。

总结一下，作者识别了一种混合存储模型、提出范围查询的安全外包模型、和节省gas的树结构。