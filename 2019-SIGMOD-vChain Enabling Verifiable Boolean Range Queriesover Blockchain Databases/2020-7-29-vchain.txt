大家好，今天和大家分享一篇数据库、密码学和区块链结合的论文。
vchain,在区块链数据库上构建可验证的布尔范围查询的方案。

首先还是提一下区块链的背景。
区块链是一种只能追加的数据结构。作为一个公共账本，由许多节点共同维护。
区块链系统有许多特点，比如hash链，不可篡改性，共识以及去中心化。

在区块链上可以构建许多应用，比如数字身份，去中心化的公证，分布式存储，智能合约等。

区块链上存储许多交易数据，对这些数据进行查询是一个关键的需求。
许多区块链数据库解决方案，支持类似SQL的查询方法。

这种方案的工作流程如图所示。通过一个可信的服务提供者，从区块链网络中获取数据，再处理好，对用户的相应查询请求去做返回。
这种方案的问题在于，服务提供者不一定是可信的。

一个验证区块链查询完整性的基础方案，是查询者自己维护一个全节点。
什么是全节点呢？
这样的代价会比较高。在存储方面，需要维护完整的区块账本。截至2019年比特币链240GB。在计算力方面，需要验证共识证明，区块是否有效。在网络方面需要同步区块。

一个更好的方案是维护一个轻节点，将计算进行外包。轻节点，只需要维护区块头。（对于比特币来说就是50MB兆）在这种情况下，如何保证查询的完整性呢？

一种方式是使用智能合约。智能合约是一种可信程序，在区块链上执行用户定义的计算。智能合约对区块数据进行读写。执行操作的完整性由共识协议保证。它提供了可信的存储和计算能力，可以看作一种可信虚拟机。
这里作了一个简单的对照，区块链可以看作计算机的存储，智能合约视为CPU。

用户向区块链提交查询参数。矿工执行计算，将数据写入区块（智能合约执行的一个步骤）。用户（通过智能合约）从区块读取数据。

方案，缺点:延迟长，共识验证区块需要的时间很长。可扩展性差，区块链交易速度有限制。隐私性，查询记录被放在区块链上（查询也是不可篡改的）。高代价，在以太坊上执行智能合约需要花费GAS。

第二种解决方案是使用可信计算。计算被外包给也许不信任的服务提供者。服务提供者返回密码学证明。用户使用密码学证明，自己检验查询结果的完整性、正确性。

将查询请求外包给全节点，使用VC来验证查询结果。
一般化的VC：表达能力强，但是代价高。
基于可信数据结构ADS的VC：高效，但是需要专门的设计。

使用VC方案来进行查询的整个流程如图所示：用户向全节点提交查询请求，全节点将结果和密码证明都返回给用户。用户通过证明可以验证，结果是否正确。
由此我们得到了Vchain的系统模型。

用户是轻节点，查询被外包给全节点。
全节点不一定是可信的，程序错误，安全漏洞，商业利益导致的不可信风险。

查询结果的安全性需要满足两个特点。
正确性：所有返回的结果都没有被篡改，且满足查询条件。
完整性：没有任何满足条件的查询结果被漏掉。

接下来我们看一下具体的设计。
矿工构造带有可信数据结构ADS的区块，来实现VC可信计算方案。
把区块头发给轻节点。区块头和区块体发送给全节点。

服务提供者是全节点，计算查询结果，并返回验证对象VO。（包含了前面说的证明）

查询用户是一个轻节点。使用验证对象VO和区块头来验证查询结果的正确性。

看着比较抽象，跟例子结合着看会比较明确。
数据模型：每一个区块包含一系列时序对象，o1，on
oi可以用一个三元组表示。ti是时间戳，Vi是一个多维向量，Wi是固定值的属性。对象就是一笔交易。

一些布尔范围查询的例子：（布尔查询，就是给定一个查询，数据库里面的记录，满足或者不满足查询条件）
找到所有发生在一个时间段中的比特币交易。
一个交易被表示为：时间戳，转账金额，发送方、接收方。
对应的查询为：2018-5，2018-6，多维数组是10到无穷到，固定值属性是发送方地址，和接收方地址。

订阅查询，符合实际场景的：用户可以先提交查询，在未来如果区块链中有满足查询条件的数据，就向相应的订阅用户返回查询结果。

注册到汽车租赁消息，搜索某价格和关键词。
交易形式为：时间戳，租赁价格，类型
查询为：因为是注册查询，就是当新交易产生的时候，符合查询条件的交易就被返回给查询者。因此这里时间戳为空。多维数据是一个价格区间，固定值属性是奔驰或者宝马。轿车。

vchain遇到的挑战：
如何为一直追加数据的区块链设计可信数据结构ADS。
如何设计一个通用的ADS方案，支持对于任意属性的动态查询。
如何使用 区块间、区块内的优化方法来提升查询效率。
如何提高系统的可扩展性，能够处理大量的注册查询。

首先看如何使用密码学技术来构建可信数据结构ADS。
一种方式是使用Merkel树，来完成数据验证的问题。能够有效验证对象是否存在，以及范围查询。
限制：
一是轻节点查询的关键词需要在MerkleTree构建的时候就确定好。如果想让它支持任意的属性查询的功能，需要很大的构建成本；
二是MerkleTree不支持属性集合的验证；
三是在区块和区块之间，使用MerkleTree不能做到聚集批量验证，无法做到效率优化。

基于密码学多重集的累加器。主要是证明集合的不相交。
需要了解几个函数的作用。为后面的方案做铺垫。
KeyGen(1λ) → (sk, pk)，产生公钥sk和密钥pk。

Setup(X, pk) → acc(X)，输入多重集X和公钥pk，计算出累加器的值acc(X）。具体怎么计算的可以暂时放下。

ProveDisjoint(X1,X2, pk) → π，输入两个多重集（这两个多重集中的元素是没有交集的）和一个公钥，输出证明π。顾名思义，这个函数是用来生成两个多重集没有交集的证明。

VerifyDisjoint(acc(X1), acc(X2), π, pk) → {0, 1}，X1累加器的值，X2累加器的值。如果输出为1，表示X1和X2没有交集。这个函数用来验证两个多重集X1和X2是否有交集。

为了说明vchain具体的工作流程，我们先考虑单个对象，和一个布尔查询 。我们先假设每个区块只存储一个对象。

首先由矿工产生可信数据结构ADS。
需要在区块头里加一个字段，属性摘要。它是属性的累加器的值acc(X）。
这个摘要的大小是固定的，无论Wi包含多少个元素。支持这两个验证函数。

服务提供者收到一个查询请求后。
如果这个对象满足查询条件，那么对象oi被返回，完整性被区块头中的对象hash证明。

如果这个对象不符合查询，使用属性摘要证明oi不符合条件。

看一个例子：一个查询条件为“Sedan”∧(“Benz”∨“BMW”)，转换成两个集合。
对象的属性是 van和benz，Sedan与对象属性的交集为空。
使用证明不相交函数，得到证明Π。

用户从区块头中，接收到属性摘要。属性、Sedan的累加器、Π，作为验证不相交函数的参数，可以验证Sedan与对象属性集不相交。因此对象不符合查询条件。

上一页ppt讲了如何对非数字类型的属性集进行布尔查询
希望将Boolean类型查询拓展到范围查询
关键在于将数字属性转换为固定值属性的方法

如何转换呢？

将一个数字转化成二进制前缀元素，转换函数表示为trans(.)，比如4可以表示为二进制100，所以trans(4) = {1∗, 10∗, 100}. 星号表示通配符

直观一点来看：
[0,7]范围内的一个二进制前缀树如图所示：

来看如何把，范围查询变成一个布尔表达式。

我们需要表示[0,6]范围，首先我们找到红线上的叶子节点是需要覆盖的，然后，我们确定{0∗,10∗,110}这三个点，使之恰好能够覆盖这些叶子节点。所以这三个灰色的节点就是我们想要的。

可以用类似布尔查询的方法来处理。

对于数字4，trans(4) = {1∗, 10∗, 100}，它是在[0, 6]范围内的，因为 相交不为空。
7相交为空，因此不处于这个范围里。这样就把范围查询转换成布尔查询。当然这里的数字都需要是整数。

再来看：批量验证与订阅查询。(如果要做查询，肯定是把历史区块全部查一遍，这个时候批量验证就很有必要)
许多对象可能由于同样的属性，不符合查询条件。
因此可以对属性集合做聚集，来加快查询处理速度。
-------------------------------------------------
区块内的索引。
用Merkel树来聚合同一个区块内对象的属性集合。
父节点中的W集合是子节点集合的总和，所以当父节点的W集合不满足查询条件时，所有的子节点都不满足。这样子就可以节省了递归二叉树的时间。
-------------------------------------------------
细节：（1）作者把交集最大的两个叶子节点生成一个父节点，然后一层层往上生长，直到根节点。（2）在非叶子节点的W匹配查询条件，还需要递归直到叶子节点。
-------------------------------------------------
第二个是区块间的索引。
使用跳表来聚合区块和区块之间对象的属性集合。

上图红圈里面的 Wl2 存储了前面（i，i-1,i-2）的所有W字段，跳跃步长为2， Wl4 存储了前面i到（i-4）所有W的字段，跳跃步长为4。存在包含关系。所以我们从右边红圈所示的队列最下端开始，判断对应的W是否匹配查询条件，如果不匹配，就表示其所跳过的区块都不匹配查询条件，因此就不需要继续往上遍历了。
-------------------------------------------------
第三个使用倒排前缀树，来聚合类似属性集合的订阅查询。
MHT 、跳表、倒排树，都是索引中常见的数据结构。
-------------------------------------------------
vChain系统提供了可以订阅的查询的功能。
传统的数据库查询为，已经存在数据，我们提交查询，然后接收结果。

这里面的可订阅查询服务的执行顺序相反。服务提供者先收集用户的查询语句，也就是注册查询，然后在未来如果有数据对象匹配这些查询条件，就将该数据对象发送给相应的用户。（因为一颗树处理多个查询，所以需要做一个索引来加快查询效率）
-------------------------------------------------
最后是做了性能测试。在两个数据集，4SQ入住信息数据集，ETH以太坊转账数据集。
一些参数设置：数值范围选择是10% 50%。逻辑或的布尔查询，在4SQ数据集里面是3个，ETH数据集里面是9个。

服务商处理查询需要花的时间
用户验证需要花的时间，服务商发送给用户的验证对象VO的大小。