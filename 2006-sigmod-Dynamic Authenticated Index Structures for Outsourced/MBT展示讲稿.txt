
今天和大家分享一篇比较经典的论文：Dynamic Authenticated Index Structures for Outsourced Databases

为外包数据库设计的动态可信数据结构。是李飞飞在波士顿大学读博的时候做的。

首先介绍一下外包数据库的系统模型。

首先存在数据的拥有者。发布数据库。

第二个是服务器，他们负责维护数据库，并提供查询服务。

第三个是客户端，他们通过请求服务器来查询数据。这里存在一个问题：如果有的服务器提供不可信的查询结果怎么办？

我们来看一个例子，这里有一个范围查询，查询在5到11之间的数据。

如果返回6、9是正确的。

对数据进行了注入，返回679。
对数据进行丢弃，返回6.
数据拥有者更新了数据，但是server没有及时更新，省略了结果。

为了保证查询的可靠，查询结果要正确、完整、与拥有者数据库中的结果一致，也就是新鲜。

我们先来看方法的整体过程。

数据拥有者和服务器都维护一个可信数据结构ADS。

服务器在向用户提供查询结果的时候，同时返回一个 verificaton object VO。用户通过VO就可以验证结果的完整性。

如何去计算开销呢？

数据拥有者计算可信数据结构ADS的开销。
用户验证VO的开销。更新ADS数据结构的开销。

首先介绍一下利用的基本密码学工具。
Hash函数（单向散列函数），单向陷门函数，就是说他具有不可逆的特性。

公钥签名。

公钥签名的方法，计算开销比较大。而Merkel hash树，计算起来就很快。

Merkel B树的结构

这是树的某一层。p是pointer指针，h是hash值。k是索引key。指针指向叶子节点。
相邻隔开的，就是一个个节点。

一般来说，一个节点存在一个page里面。在给定页page大小的情况下，B+树扇出由下面这个公式得到。扇出就是说，一个节点有几个子节点。

首先来看一下会用到的符号。都是比较直观的。

r是数据库中的记录。x是对象的大小。ND 和NR 代表了数据库记录和查询结果的数量。

fx是某个结构x的扇出。dx是该结构的高度。Hlx是长度为l的输入对象x的哈希操作。

对于MB树里的范围查询。这是一个查询路径。这是查询的子树。这是查询的左边界，这是查询的右边界。

这是B+树的某一层，中间节点internalnode。他的子节点是叶子节点 leafnode。查询结果是L6到L12. L5就是左边界。

把L1到L4的哈希值返回。同时返回I1到I4的哈希值。

我们结合一个具体的例子来看。当扇出f为2，即每个中间节点有两个子节点的情况。

5到11的一个范围查询，查询结果是6和9.
左边界是5，右边界是12。查询子树的起点。搜索路径。VO是5 12 h14和root哈希。

客户端做验证的过程很简单。

h14的子树不需要知道。通过左右边界+查询结构，构建查询子树。最后构建root哈希。root哈希如果和拥有者的root哈希相同，那么查询结果是正确完整的。

当扇出是5的时候，查询结果q在这里。左边界是5，右边界是10. 同时返回13 12 14 16的哈希。20 29 42 的哈希入口。8个哈希。

我们计算一下VO的大小。

沿着查询子树的两个边界路径的节点的相邻入口的hash。加上查询子树上一级节点相邻入口的hash. 它给了一个形式化公式。

Embedded Merkle B (EMB) Tree

我们可以看到上面这个公式VO最小的时候，扇出f是2，但是查询效率这样很低。

把一个子节点变成MB树的形式。新的树的扇出是fe。上一层节点的hash是该树的root。

因此每个MB扇出是fk，子节点MB树的扇出是fe。

来看具体的例子：5和10是边界，红色节点的hash

EMB树的变种。嵌入树的计算，是即时的，不需要存储嵌入树。用其他树结构代替B+树。

相对于EMB的对照组，一种比较笨的办法是使用签名树。签名树的优化是聚合签名树。

最后是实验：测试了树的构造时间、存储大小、查询IO、VO构造IO、VO大小、用户验证VO花费的时间

对照组签名树的更新代价、MBtree的更新代价。

展望一下：这里是范围查询，是否可以拓展为其他查询类型。是否可以定义更多可信的维度，查询正确性、完整性、及时性。