今天跟大家分享一篇usenix17的论文，是关于数据库权限控制的
用户可以通过web应用来获取在线服务。
他们后端的信息都是存储在数据库里的。
数据库就容易成为攻击者的目标。
2016年的时候赛锰铁克的数据库漏洞。

可以通过两种比较好的方式实现权限控制。
一种是直接在数据库中做内置的权限控制。
比如Oracle和postgres就是直接在数据库里面定义权限控制。
用户连接到数据库后再进行操作。
这样的模型有一个问题：数据库用户和应用用户不同。

一般为了良好的性能，在应用和数据库之间有一个连接池。
这些连接来操作数据。
一个问题是：数据库有其特定的语法来定义权限控制。
Oracle和postgres 的权限控制语言是不通用的。也比较复杂。
不能只了解SQL语法。

另一种思路是：如果连接池没有应用用户的信息，不如直接把权限控制做在应用服务器端。
类似的工作有clamp和nemesis。他们主要是通过数据库视图来实现的。

数据库视图是一个比较通用的方法，来限制用户查看数据库的内容。
语法和sql差不多，这个例子是用户只允许查看自己的订单信息。

这是一个write策略限制，只允许用户 更新自己的 订单。
使用 数据库视图 可以做到。但是需要 table 可以和 用户 连接 map起来。

但是如果做不到怎么办？比如表里没有 userID这一列。
或者说在这种 上下文 中，userID不足以提供这种匹配。

举个例子：用户只能对自己购买的商品进行评价。

review table 也许有 userID 域。
但是review table 不知道用户购买了什么商品。

所以在使用数据库视图的时候，在where的定义里面需要用and来连接很多表。

但是这里的视图 不是不可更改的。
所以用户做的操作不一定是正确的。
数据库里的join连接操作，map可能会出现错误。（由于数据库规范化）


他调查了一下，在实际web应用中，join操作的使用频率。
平均大概21%的情况下，数据库没办法定义安全的写策略。                                                 

所以有的人会选择使用远程权限控制。
但是这样会带来很多漏洞。下面有一组数据，在5年里跟踪396个开源的web应用，发现有269个漏洞。
比如 简单的SQL注入，其实如果有后台数据库有做好权限控制的话就可以避免。

前面提到的赛锰铁克漏洞也是通过SQL注入获得admin级别的数据库权限。

文章提出了4个设计目标。权限控制必须包括读写请求。
第二个是正确性，实际的行为要遵守权限控制。
第三在架构上有通用性。现有的web应用不需要做出很大的改变。
不是仅针对某个数据库的。如果从Oracle换到postgres，权限控制的代码也是可用的。
最后要简单，开发人员可以很快上手。

所以他们决定要改driver，如果是用java写的话，就是JDBC(Java DataBase Connectivity,
是一个java数据库连接的代码库
因为它就是在应用端的，所以可以获得应用端用户的上下文 信息。
也可以拦截所有的请求，在实际执行之前，确保请求是符合权限控制策略的。

首先解释什么是请求的安全性
然后是怎么实施这种安全策略
最后实验了这种方法的性能

先解释一下数据库策略：有两种读和写的策略
policy规定了用户可以访问的数据库表的内容

这个例子比较简单：读、写策略是相同的。
用户只能查看、修改自己的order

下一个例子里面，规定了用户只能读 待售商品的信息。

最后一个例子里的写策略比较复杂，会涉及到join操作。

他把这种安全性 分成了 读安全和写安全

读安全就是用户只能看到授权的信息

一个例子：如果用户id是1，那么这个请求会返回所有信息，不是读安全的

写安全也是类似的：首先必须是读安全的请求，其次不能修改未授权信息

这是一个写策略。这个请求就是不安全的，这个请求操作会改变我们限定的数据库信息。

第二个请求的话，这个select就已经是 非读安全的了。

然后看driver是如何具体实现query safety的。

首先driver会 在数据库执行之前 拦截所有的query。

接着通过Read Set Intersection，把它们变成读安全的请求。

如果是一个select 请求就执行；
如果是一个写请求，比如更新、插入、删除，那就需要Phantom Extraction操作。
把它们变成写安全的请求，再去执行。

Read Set Intersection的方法就比较简单。
在SQL语句里面加上where的限定就可以做到。在paper里面有具体的公式证明。

Phantom Extraction分成两步。第一步就是Read Set Intersection。
第二步要将query的执行结果限定在写策略允许修改的 元组里面。
用两种策略来检查是否写安全的：V-copy No-copy

V-copy就是view视图的copy。它利用了数据库中临时的表，它的结果一定是安全的。

一个例子：id为1的用户，要做一个插入请求，要插入用户2的order
肯定不是读安全的。driver会拦截请求，复制修改内容的表。
然后检查是否符合写策略。它改变了 写策略允许修改的 元组。
所以返回的是空值，不改变结果。

第二个例子是delete操作，也是不安全的。
这里会用到隐式信息。
V-copy会把4 和1放到临时表里。执行delete操作后，符合写策略。
所以在数据库上执行。虽然这个delete操作不完整，但是因为有隐式信息。
V-copy的执行结果是安全的，所以也可以在数据库上执行的。

No-Copy有一定的适用条件的：比如不要求join操作。

比如前面的delete，其实可以不用到空表。
比如这个delete操作，可以直接加一个where语句。

他们定制了JDBC driver。实现了V-copy和No-copy。也具有分析query语法的功能。
他们使用了TPC-C Benchmark，是一个性能测评领域普遍使用的工具。
包含了5种交易类型。Customer和Managers两种角色身份。
设置了9种权限控制策略。
比如第一行，Customer的几个id属性，要和表里的对应上才能去修改它。
类似的，manger对district和 warehouse仓库表 要属性对上才能修改。

然后测试时延和吞吐量。公式是benchmark工具给出的。

在工作负载中query是安全的情况下。
对于没有内置权限控制的数据库来说，SafeD性能开销如何。测试对象是MySQL。
比起有内置权限控制的数据库来说如何。测试对象是postgres。

如果存在不安全的query，不安全请求的数量在整个工作负载里面增加的时候，对整体的性能有何影响。

SafeD大概会造成百分之六的性能开销。

对于PostgreSQL 来说，SafeD和它内置的权限控制性能开销差不多。
红色的柱代表内置权限控制的性能。

那如果我们把策略改一下会怎么样？
加入join操作。其他权限控制应用在数据库join操作的时候会产生问题。

这样的话，内置的权限控制受影响比较严重。
V-copy就没画出来，因为有join操作的时候 用视图 特别影响性能。
红色的和紫色的比较，大概相差一个数量级。

如果我们denormalization反规范化数据库中的表，就是不需要用到join操作。
但是这样的话，数据库中的表都会很大。规范化是减少数据冗余度的。
反规范化会增大表。
这个时候，内置的权限控制性能大大提高。但是no-copy性能还是比较高。
至少在PostgreSQL数据库中，SafeD可以获得较好的性能。

接下去他随机地加了一些不安全的读写请求到工作负载中。
来看性能测试结果。不安全请求的比例从0到百分之10，假设攻击者无法发特别多的不安全请求
时延上，V-copy性能开销特别大，而no-copy基本不变。
吞吐量上，no-copy最低350tps，V-copy就会一直下降。

最后是语法方面的要求。SafeD掌握select，借鉴了数据库视图。
Oracle是最复杂的。

之前实现的权限控制：9个表18个权限控制定义，两种角色，所以SafeD是36个规则。
Oracle比较复杂需要544行代码。

因为修改的是driver所以可以比较好地适应现有web应用的架构，独立于数据库。
